#!/usr/bin/env node
/**
 * Post-build script to create stable index.mjs entry points
 * 
 * Problem: ESMX build generates hashed filenames (entry.client.{hash}.final.mjs)
 * but public/index.html tries to import static paths (/client/src/index.mjs)
 * 
 * Solution: Create index.mjs files that re-export from the hashed entry files
 * so imports remain stable across builds
 */

import { readdirSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// All micro-apps that need index.mjs entry points
const microApps = [
  'ssr-react',
  'ssr-vue2', 
  'ssr-vue3',
  'ssr-vue3-ecommerce',
  'ssr-vue3-admin'
];

// Base directory for micro-apps - go up one level from scripts/
const baseDir = join(__dirname, '..', 'my-super-app');

/**
 * Find the entry.client.*.final.mjs file in the client/src directory
 */
function findEntryClient(appDir) {
  const clientSrcDir = join(baseDir, appDir, 'dist', 'client', 'src');
  
  if (!existsSync(clientSrcDir)) {
    console.warn(`âš ï¸  ${appDir}: client/src directory not found at ${clientSrcDir}`);
    return null;
  }

  try {
    const files = readdirSync(clientSrcDir);
    const entryFile = files.find(f => 
      f.startsWith('entry.client.') && f.endsWith('.final.mjs')
    );
    
    if (entryFile) {
      return { dir: clientSrcDir, file: entryFile };
    }
    
    console.warn(`âš ï¸  ${appDir}: entry.client.*.final.mjs not found in ${clientSrcDir}`);
    return null;
  } catch (err) {
    console.error(`âŒ ${appDir}: Error reading directory: ${err.message}`);
    return null;
  }
}

/**
 * Create index.mjs that re-exports from the hashed entry file
 */
function createIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { dir, file } = entryInfo;
  const indexPath = join(dir, 'index.mjs');
  
  // Create re-export content
  // We use export * to re-export all named exports
  // and export { default } for the default export
  const content = `// Auto-generated by post-build script
// This file provides a stable entry point that re-exports from the hashed build output
// Generated at: ${new Date().toISOString()}

export * from './${file}';
export { default } from './${file}';
`;

  try {
    writeFileSync(indexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${indexPath} â†’ ./${file}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Also create root index.mjs if the app has one in dist/
 */
function createRootIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { file } = entryInfo;
  const distDir = join(baseDir, appDir, 'dist');
  const rootIndexPath = join(distDir, 'index.mjs');
  
  // Only create if dist/index.mjs exists or we want to overwrite it
  // The import path is relative from dist/ to dist/client/src/{file}
  const content = `// Auto-generated by post-build script
// Root entry point that re-exports from client build
// Generated at: ${new Date().toISOString()}

export * from './client/src/${file}';
export { default } from './client/src/${file}';
`;

  try {
    writeFileSync(rootIndexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${rootIndexPath}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create root index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸ”§ Post-build: Creating stable index.mjs entry points...\n');
  
  let successCount = 0;
  let failCount = 0;
  
  for (const app of microApps) {
    const entryInfo = findEntryClient(app);
    
    if (entryInfo) {
      const clientSuccess = createIndexMjs(app, entryInfo);
      const rootSuccess = createRootIndexMjs(app, entryInfo);
      
      if (clientSuccess || rootSuccess) {
        successCount++;
      } else {
        failCount++;
      }
    } else {
      failCount++;
    }
  }
  
  console.log(`\nðŸ“Š Summary: ${successCount} succeeded, ${failCount} failed`);
  
  if (failCount > 0) {
    process.exit(1);
  }
  
  console.log('âœ¨ Post-build complete!');
}

main();
