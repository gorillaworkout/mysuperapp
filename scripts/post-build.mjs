#!/usr/bin/env node
/**
 * Post-build script to create stable index.mjs entry points
 * 
 * Problem: ESMX build generates hashed filenames (entry.client.{hash}.final.mjs)
 * but public/index.html tries to import static paths (/client/src/index.mjs)
 * 
 * Solution: Create index.mjs files that re-export from the hashed entry files
 * so imports remain stable across builds
 */

import { readdirSync, writeFileSync, existsSync, mkdirSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// All micro-apps that need index.mjs entry points
const microApps = [
  'ssr-react',
  'ssr-vue2', 
  'ssr-vue3',
  'ssr-vue3-ecommerce',
  'ssr-vue3-admin',
  'ssr-npm-react',
  'ssr-npm-vue2',
  'ssr-npm-vue3'
];

// Base directory for micro-apps - go up one level from scripts/
const baseDir = join(__dirname, '..', 'my-super-app');

/**
 * Find the entry.client.*.final.mjs file in the client/src directory
 */
function findEntryClient(appDir) {
  const clientSrcDir = join(baseDir, appDir, 'dist', 'client', 'src');
  
  if (!existsSync(clientSrcDir)) {
    console.warn(`âš ï¸  ${appDir}: client/src directory not found at ${clientSrcDir}`);
    return null;
  }

  try {
    const files = readdirSync(clientSrcDir);
    const entryFile = files.find(f => 
      f.startsWith('entry.client.') && f.endsWith('.final.mjs')
    );
    
    if (entryFile) {
      return { dir: clientSrcDir, file: entryFile };
    }
    
    console.warn(`âš ï¸  ${appDir}: entry.client.*.final.mjs not found in ${clientSrcDir}`);
    return null;
  } catch (err) {
    console.error(`âŒ ${appDir}: Error reading directory: ${err.message}`);
    return null;
  }
}

function shouldExportDefault(appDir) {
  return !appDir.startsWith('ssr-npm-');
}

function isVueProvider(appDir) {
  return appDir === 'ssr-npm-vue2' || appDir === 'ssr-npm-vue3';
}

function isReactProvider(appDir) {
  return appDir === 'ssr-npm-react';
}

/**
 * Create stable React entry files with proper ESM exports
 * 
 * The bundled React from ESMX/Rspack is a CommonJS IIFE that doesn't have proper ESM exports.
 * We solve this by creating ESM wrappers that:
 * 1. Execute the bundled IIFE to get the React object
 * 2. Re-export all React APIs as named ESM exports
 * 
 * This approach works entirely offline - no CDN required!
 */
function createReactProviderEntries(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client');
  if (!existsSync(clientDir)) return false;

  // Find the bundled React files
  let reactBundleFile = null;
  let reactDomBundleFile = null;
  
  try {
    const files = readdirSync(clientDir);
    reactBundleFile = files.find(f => f.startsWith('react.') && f.endsWith('.final.mjs') && !f.includes('react-dom'));
    reactDomBundleFile = files.find(f => f.startsWith('react-dom.') && f.endsWith('.final.mjs'));
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to read client dir: ${err.message}`);
    return false;
  }

  if (!reactBundleFile || !reactDomBundleFile) {
    console.error(`âŒ ${appDir}: Could not find React bundle files`);
    return false;
  }

  // Read the bundled React file
  const bundlePath = join(clientDir, reactBundleFile);
  let bundleContent;
  try {
    bundleContent = readFileSync(bundlePath, 'utf-8');
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to read React bundle: ${err.message}`);
    return false;
  }
  
  // The bundle structure is:
  // var e={...},t={};!function r(n){...}(155);
  // The IIFE returns the exports but doesn't assign to anything
  // We need to modify it to return the result
  
  // Transform the bundle: change "!function" to "return function" so we can capture the result
  // Also need to handle the case where it might start with "var e=..."
  let modifiedBundle = bundleContent;
  
  // The bundle ends with: }(155); or similar
  // We need to wrap it so the IIFE result is returned
  // Strategy: wrap entire bundle and return the result of the IIFE
  
  // Find and modify the IIFE invocation pattern
  // Pattern: !function r(n){...}(155);
  // Change to: (function r(n){...})(155)
  // Then we can capture the return value
  
  // Actually, looking at the bundle structure more carefully:
  // The IIFE is structured to populate t[155].exports
  // But we need to capture that value
  
  // Simpler approach: append code to return the exports
  // After the IIFE runs, t[155].exports contains React
  // We can access it by modifying the structure
  
  // Transform: wrap in a function that captures the webpack runtime result
  const transformedReact = `// Auto-generated by post-build script
// ESM wrapper for React 18.3.1 - NO CDN REQUIRED
// Generated at: ${new Date().toISOString()}

// Execute bundled React and capture exports
// The bundle uses webpack-style runtime: e=modules, t=cache
// After execution, the result is in the module cache
const React = (function() {
  // The bundled code structure:
  // var e={...modules...},t={};!function r(n){...runtime...}(155);
  // We modify it to return the result
  
  var __result;
  
  // Execute bundle with modified IIFE to capture result
  ${bundleContent.replace(
    /!\s*function\s+(\w+)\s*\((\w+)\)\s*\{/,
    '__result = (function $1($2) {'
  ).replace(
    /\}\s*\(\s*(\d+)\s*\)\s*;?\s*$/,
    '})($1);'
  )}
  
  return __result;
})();

// Named exports
export const Children = React.Children;
export const Component = React.Component;
export const Fragment = React.Fragment;
export const Profiler = React.Profiler;
export const PureComponent = React.PureComponent;
export const StrictMode = React.StrictMode;
export const Suspense = React.Suspense;
export const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
export const act = React.act;
export const cloneElement = React.cloneElement;
export const createContext = React.createContext;
export const createElement = React.createElement;
export const createFactory = React.createFactory;
export const createRef = React.createRef;
export const forwardRef = React.forwardRef;
export const isValidElement = React.isValidElement;
export const lazy = React.lazy;
export const memo = React.memo;
export const startTransition = React.startTransition;
export const unstable_act = React.unstable_act;
export const useCallback = React.useCallback;
export const useContext = React.useContext;
export const useDebugValue = React.useDebugValue;
export const useDeferredValue = React.useDeferredValue;
export const useEffect = React.useEffect;
export const useId = React.useId;
export const useImperativeHandle = React.useImperativeHandle;
export const useInsertionEffect = React.useInsertionEffect;
export const useLayoutEffect = React.useLayoutEffect;
export const useMemo = React.useMemo;
export const useReducer = React.useReducer;
export const useRef = React.useRef;
export const useState = React.useState;
export const useSyncExternalStore = React.useSyncExternalStore;
export const useTransition = React.useTransition;
export const version = React.version;

export default React;
`;

  // ReactDOM bundle structure:
  // import*as e from"react";var n={...},t={};!function e(r){...}(316);
  // 
  // This is a HYBRID format:
  // - Starts with ESM import for React
  // - Uses webpack-style CommonJS runtime internally
  // - IIFE at the end returns exports but discards them
  //
  // Solution: Capture the IIFE result and re-export properly
  const reactDomBundlePath = join(clientDir, reactDomBundleFile);
  const reactDomBundleContent = readFileSync(reactDomBundlePath, 'utf-8');
  
  // Transform the bundle:
  // 1. Fix React import path: "react" -> "./react.mjs"
  // 2. Capture IIFE result at END of file: },t={};!function e(r){...}(316);
  //    -> },t={};var __ReactDOMExports = (function e(r){...})(316);
  // 3. Export the captured result
  
  let fixedContent = reactDomBundleContent
    // Fix React import path
    .replace(
      /import\s*\*\s*as\s+(\w+)\s+from\s*["']react["']/g,
      'import * as $1 from "./react.mjs"'
    );
  
  // Find the webpack runtime IIFE at the end of the file
  // Pattern: },t={};!function e(r){...}(316);
  // This is the LAST !function in the file, so we need to match it specifically
  // The pattern is: }(number) at the very end, preceded by the IIFE
  const iifeMatch = fixedContent.match(/},\s*(\w+)\s*=\s*\{\s*\}\s*;\s*!\s*function\s+(\w+)\s*\((\w+)\)\s*\{(.+)\}\s*\(\s*(\d+)\s*\)\s*;?\s*$/s);
  
  if (iifeMatch) {
    // iifeMatch[1] = cache var name (t)
    // iifeMatch[2] = function name (e)  
    // iifeMatch[3] = param name (r)
    // iifeMatch[4] = function body
    // iifeMatch[5] = entry point number (316)
    const cacheVar = iifeMatch[1];
    const funcName = iifeMatch[2];
    const paramName = iifeMatch[3];
    const funcBody = iifeMatch[4];
    const entryPoint = iifeMatch[5];
    
    // Replace the IIFE with a variable assignment
    fixedContent = fixedContent.replace(
      /},\s*(\w+)\s*=\s*\{\s*\}\s*;\s*!\s*function\s+(\w+)\s*\((\w+)\)\s*\{(.+)\}\s*\(\s*(\d+)\s*\)\s*;?\s*$/s,
      `},${cacheVar}={};var __ReactDOMExports = (function ${funcName}(${paramName}) {${funcBody}})(${entryPoint});`
    );
  } else {
    console.warn('âš ï¸ ReactDOM: Could not find webpack runtime IIFE pattern');
  }
  
  const transformedReactDom = `// Auto-generated by post-build script
// ESM wrapper for ReactDOM 18.3.1 - NO CDN REQUIRED
// Generated at: ${new Date().toISOString()}

${fixedContent}

// Export ReactDOM APIs from captured webpack exports
export const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = __ReactDOMExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
export const createPortal = __ReactDOMExports.createPortal;
export const flushSync = __ReactDOMExports.flushSync;
export const hydrate = __ReactDOMExports.hydrate;
export const render = __ReactDOMExports.render;
export const unmountComponentAtNode = __ReactDOMExports.unmountComponentAtNode;
export const unstable_batchedUpdates = __ReactDOMExports.unstable_batchedUpdates;
export const version = __ReactDOMExports.version;
export const findDOMNode = __ReactDOMExports.findDOMNode;
export const createRoot = __ReactDOMExports.createRoot;
export const hydrateRoot = __ReactDOMExports.hydrateRoot;

// Default export for compatibility
const ReactDOM = {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  createPortal,
  flushSync,
  hydrate,
  render,
  unmountComponentAtNode,
  unstable_batchedUpdates,
  version,
  findDOMNode,
  createRoot,
  hydrateRoot,
};
export default ReactDOM;
`;

  // ReactDOM/client for React 18 APIs
  const transformedReactDomClient = `// Auto-generated by post-build script
// ESM wrapper for ReactDOM/client 18.3.1 - NO CDN REQUIRED
// Generated at: ${new Date().toISOString()}

import ReactDOM from '../react-dom.mjs';

// React 18 client APIs
export const createRoot = ReactDOM.createRoot;
export const hydrateRoot = ReactDOM.hydrateRoot;
`;

  const reactMjsPath = join(clientDir, 'react.mjs');
  
  try {
    writeFileSync(reactMjsPath, transformedReact, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactMjsPath} (ESM wrapper - NO CDN)`);
    
    const reactDomMjsPath = join(clientDir, 'react-dom.mjs');
    writeFileSync(reactDomMjsPath, transformedReactDom, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactDomMjsPath} (ESM wrapper - NO CDN)`);
    
    // Create react-dom subdirectory if needed
    const reactDomClientDir = join(clientDir, 'react-dom');
    if (!existsSync(reactDomClientDir)) {
      mkdirSync(reactDomClientDir, { recursive: true });
    }
    const reactDomClientPath = join(reactDomClientDir, 'client.mjs');
    writeFileSync(reactDomClientPath, transformedReactDomClient, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactDomClientPath} (ESM wrapper - NO CDN)`);
    
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create React wrappers: ${err.message}`);
    return false;
  }
}

function createVueProviderIndex(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client', 'src');
  if (!existsSync(clientDir)) return false;

  const isVue2 = appDir === 'ssr-npm-vue2';
  const indexPath = join(clientDir, 'index.mjs');

  const content = `// Auto-generated by post-build script
// Stable provider entry for ${appDir}
// Generated at: ${new Date().toISOString()}

${isVue2 ? "import Vue from 'vue';" : "import { computed, inject, shallowRef, h } from 'vue';"}
import { Router } from '@esmx/router';

${isVue2 ? `const RouterVuePlugin = {
  install(vueInstance, options) {
    const router =
      (options && options.router) ||
      (typeof Router.getInstance === 'function' ? Router.getInstance() : null);
    if (!router) {
      console.warn('[esmx-router-vue2] Router instance not provided.');
      return;
    }
    this.router = router;

    // Support sharedRouter for cross-app navigation
    const sharedRouter = options && options.sharedRouter;
    if (sharedRouter) {
      vueInstance.prototype.$sharedRouter = sharedRouter;
    }

    vueInstance.prototype.$router = router;

    vueInstance.mixin({
      beforeCreate() {
        if (this.$options.router) {
          this._routerRoot = this;
          this._router = router;

          try {
            this._route = router.route;
          } catch (e) {}

          const unsubscribe = router.afterEach((route) => {
            this._route = route;
            this.$forceUpdate();
          });

          this.$once('hook:destroyed', unsubscribe);
        } else {
          this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
        }
      },
      destroyed() {
        if (this._routerRoot === this) {
          this._routerRoot = null;
        }
      }
    });

    Object.defineProperty(vueInstance.prototype, '$route', {
      get() { return this._routerRoot._route || {}; }
    });

    vueInstance.component('router-link', {
      props: {
        to: { type: [String, Object], required: true },
        replace: { type: Boolean, default: false },
        activeClass: { type: String, default: 'active' },
        tag: { type: String, default: 'a' }
      },
      render(h) {
        const path = typeof this.to === 'string' ? this.to : this.to.path;
        const isActive = this.$router && path === window.location.pathname;

        const classes = [];
        if (this.$vnode.data && this.$vnode.data.staticClass) {
          classes.push(this.$vnode.data.staticClass);
        }
        if (isActive && this.activeClass) {
          classes.push(this.activeClass);
        }

        // Use sharedRouter for cross-app navigation if available, fallback to localRouter
        const router = this.$sharedRouter || this.$router;

        const data = {
          class: classes,
          on: {
            click: (e) => {
              e.preventDefault();
              router.push(path, this.replace);
            }
          },
          attrs: { href: path }
        };

        return h(this.tag, data, this.$slots.default);
      }
    });

    vueInstance.component('router-view', {
      data() {
        return {
          currentRoute: router.route
        };
      },
      created() {
        // Subscribe to route changes and update local state
        this._unsubscribe = router.afterEach((route) => {
          this.currentRoute = route;
        });
      },
      beforeDestroy() {
        if (this._unsubscribe) {
          this._unsubscribe();
        }
      },
      render(h) {
        const route = this.currentRoute || this.$route;
        const matched = route && route.matched;
        const component = matched && matched.length > 0
          ? matched[matched.length - 1].component
          : null;

        if (!component) return null;
        return h(component);
      }
    });
  }
};

function install(vueInstance, options) {
  vueInstance.use(RouterVuePlugin, options);
}

function RouterView(VueCtor) {
  const router = Router.getInstance && Router.getInstance();
  return VueCtor.component('router-view', {
    data() {
      return {
        currentRoute: router ? router.route : null
      };
    },
    created() {
      if (router) {
        this._unsubscribe = router.afterEach((route) => {
          this.currentRoute = route;
        });
      }
    },
    beforeDestroy() {
      if (this._unsubscribe) {
        this._unsubscribe();
      }
    },
    render(h) {
      const route = this.currentRoute || this.$route;
      const matched = route && route.matched;
      const component = matched && matched.length > 0
        ? matched[matched.length - 1].component
        : null;
      if (!component) return null;
      return h(component);
    }
  });
}

function RouterLink(VueCtor) {
  return VueCtor.component('router-link', {
    props: {
      to: { type: [String, Object], required: true },
      replace: { type: Boolean, default: false },
      activeClass: { type: String, default: 'active' },
      tag: { type: String, default: 'a' }
    },
    render(h) {
      const localRouter = this.$router || (Router.getInstance && Router.getInstance());
      const sharedRouter = this.$sharedRouter || null;
      const path = typeof this.to === 'string' ? this.to : this.to.path;
      const isActive = localRouter && path === window.location.pathname;

      const classes = [];
      if (isActive && this.activeClass) {
        classes.push(this.activeClass);
      }

      const currentPath = window.location.pathname;
      const currentAppPrefix = currentPath.split('/').slice(0, 2).join('/');
      const isCrossAppNavigation = !path.startsWith(currentAppPrefix) || path === '/';

      const data = {
        class: classes,
        on: {
          click: (e) => {
            e.preventDefault();
            if (sharedRouter) {
              if (this.replace) sharedRouter.replace(path);
              else sharedRouter.push(path);
            } else if (isCrossAppNavigation) {
              if (this.replace) window.location.replace(path);
              else window.location.href = path;
            } else if (localRouter) {
              localRouter.push(path, this.replace);
            }
          }
        },
        attrs: { href: path }
      };

      return h(this.tag, data, this.$slots.default);
    }
  });
}
` : `const RouterVuePlugin = {
  install(app, options) {
    const router = options && options.router;
    if (!router) {
      console.warn('RouterVuePlugin installed without router instance.');
      return;
    }

    // Support sharedRouter for cross-app navigation
    const sharedRouter = options && options.sharedRouter;
    if (sharedRouter) {
      app.config.globalProperties.$sharedRouter = sharedRouter;
      app.provide('sharedRouter', sharedRouter);
    }

    app.config.globalProperties.$router = router;
    app.provide('router', router);

    const routeRef = shallowRef(router.route);
    app.provide('route', routeRef);

    const unsubscribe = router.afterEach((to) => {
      routeRef.value = to;
    });

    app.mixin({
      beforeUnmount() {
        if (this.$options.name === 'App' || this === (app._instance && app._instance.proxy)) {
          unsubscribe();
        }
      }
    });

    app.component('router-link', {
      props: {
        to: { type: [String, Object], required: true },
        replace: { type: Boolean, default: false },
        activeClass: { type: String, default: 'active' }
      },
      setup(props, { slots }) {
        const localRouter = inject('router');
        const sharedRouter = inject('sharedRouter', null);
        const routeRef = inject('route');

        const path = computed(() => typeof props.to === 'string' ? props.to : props.to.path);

        const isActive = computed(() => {
          return routeRef.value && routeRef.value.path === path.value;
        });

        const classes = computed(() => {
          const result = [];
          if (isActive.value && props.activeClass) result.push(props.activeClass);
          return result;
        });

        const handleClick = (e) => {
          e.preventDefault();
          const currentPath = routeRef.value?.path || '';
          const currentAppPrefix = currentPath.split('/').slice(0, 2).join('/');
          const isCrossAppNavigation = !path.value.startsWith(currentAppPrefix) || path.value === '/';
          
          if (sharedRouter) {
            if (props.replace) sharedRouter.replace(path.value);
            else sharedRouter.push(path.value);
          } else if (isCrossAppNavigation) {
            if (props.replace) window.location.replace(path.value);
            else window.location.href = path.value;
          } else {
            if (props.replace) localRouter.replace(path.value);
            else localRouter.push(path.value);
          }
        };

        return () => h('a', {
          href: path.value,
          class: classes.value,
          onClick: handleClick
        }, slots.default ? slots.default() : []);
      }
    });

    app.component('router-view', {
      setup() {
        const routeRef = inject('route');
        const Component = computed(() => {
          if (!routeRef || !routeRef.value) return null;
          const matched = routeRef.value.matched;
          return matched && matched.length > 0 ? matched[matched.length - 1].component : null;
        });
        return () => Component.value ? h(Component.value) : null;
      }
    });
  }
};

function install(app, options) {
  app.use(RouterVuePlugin, options);
}

function useRouter() {
  const router = inject('router');
  if (!router) {
    throw new Error('useRouter must be used within RouterProvider (via RouterVuePlugin)');
  }
  return router;
}

function useRoute() {
  const route = inject('route');
  if (!route) {
    throw new Error('useRoute must be used within RouterProvider (via RouterVuePlugin)');
  }
  return route;
}
`}

export { RouterVuePlugin, install };
${isVue2 ? 'export { RouterLink, RouterView };' : 'export { useRouter, useRoute };'}
export * from 'vue';
${isVue2 ? "export { default } from 'vue';" : ''}
export * from '@esmx/router';
`;

  try {
    writeFileSync(indexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${indexPath} (custom provider entry)`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create provider index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create index.mjs that re-exports from the hashed entry file
 */
function createIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { dir, file } = entryInfo;
  const indexPath = join(dir, 'index.mjs');
  const exportDefault = shouldExportDefault(appDir);

  if (isVueProvider(appDir)) {
    return createVueProviderIndex(appDir);
  }
  
  // Create re-export content
  // We use export * to re-export all named exports
  // and export { default } for the default export
  const content = `// Auto-generated by post-build script
// This file provides a stable entry point that re-exports from the hashed build output
// Generated at: ${new Date().toISOString()}

export * from './${file}';
${exportDefault ? `export { default } from './${file}';` : ''}
`;

  try {
    writeFileSync(indexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${indexPath} â†’ ./${file}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Also create root index.mjs if the app has one in dist/
 */
function createRootIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { file } = entryInfo;
  const distDir = join(baseDir, appDir, 'dist');
  const rootIndexPath = join(distDir, 'index.mjs');
  const exportDefault = shouldExportDefault(appDir);
  
  // Only create if dist/index.mjs exists or we want to overwrite it
  // The import path is relative from dist/ to dist/client/src/{file}
  const isProvider = isVueProvider(appDir);
  const clientTarget = isProvider ? 'index.mjs' : file;
  const rootExportDefault =
    isProvider ? appDir === 'ssr-npm-vue2' : exportDefault;

  const content = `// Auto-generated by post-build script
// Root entry point that re-exports from client build
// Generated at: ${new Date().toISOString()}

export * from './client/src/${clientTarget}';
${rootExportDefault ? `export { default } from './client/src/${clientTarget}';` : ''}
`;

  try {
    writeFileSync(rootIndexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${rootIndexPath}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create root index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create stable vue.mjs entry for ssr-npm-vue2/ssr-npm-vue3
 * Vue2 needs a default export (Vue constructor). Vue3 does not have default export.
 */
function createStableVueEntry(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client');
  if (!existsSync(clientDir)) return false;

  try {
    const files = readdirSync(clientDir);
    const vueFile = files.find(f => f.startsWith('vue.') && f.endsWith('.final.mjs'));
    if (!vueFile) return false;

    const vueStablePath = join(clientDir, 'vue.mjs');
    const content = `// Auto-generated by post-build script
// Stable Vue bundle entry for ${appDir}
// Generated at: ${new Date().toISOString()}

export * from './${vueFile}';
${appDir === 'ssr-npm-vue2' ? `export { default } from './${vueFile}';` : ''}
`;
    writeFileSync(vueStablePath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${vueStablePath} â†’ ./${vueFile}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create vue.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create shared module index files for ssr-npm-base
 * This creates stable entry points for @esmx/router, @esmx/class-state, etc.
 */
function createSharedModuleIndexes() {
  const baseDir = join(__dirname, '..', 'my-super-app', 'ssr-npm-base');
  const clientDir = join(baseDir, 'dist', 'client');
  
  if (!existsSync(clientDir)) {
    console.warn('âš ï¸  ssr-npm-base: client directory not found');
    return false;
  }

  const esmxDir = join(clientDir, '@esmx');
  if (!existsSync(esmxDir)) {
    console.warn('âš ï¸  ssr-npm-base: @esmx directory not found');
    return false;
  }

  const sharedModules = [
    { name: 'router', prefix: 'router.' },
    { name: 'class-state', prefix: 'class-state.' }
  ];
  let success = true;

  try {
    const files = readdirSync(esmxDir);
    
    for (const mod of sharedModules) {
      const moduleFile = files.find(f => f.startsWith(mod.prefix) && f.endsWith('.final.mjs'));
      
      if (moduleFile) {
        const moduleDir = join(esmxDir, mod.name);
        
        if (!existsSync(moduleDir)) {
          mkdirSync(moduleDir, { recursive: true });
        }
        
        const indexPath = join(moduleDir, 'index.mjs');
        const content = `// Auto-generated by post-build script
// Stable entry for @esmx/${mod.name}
// Generated at: ${new Date().toISOString()}

export * from '../${moduleFile}';
`;
        writeFileSync(indexPath, content, 'utf-8');
        console.log(`âœ… ssr-npm-base: Created ${indexPath} â†’ ../${moduleFile}`);
      }
    }
  } catch (err) {
    console.error(`âŒ ssr-npm-base: Failed to create shared module indexes: ${err.message}`);
    success = false;
  }

  // Create root client index.mjs that re-exports all shared modules

  const rootIndexPath = join(clientDir, 'index.mjs');
  const rootContent = `// Auto-generated by post-build script
// Root shared modules entry
// Generated at: ${new Date().toISOString()}

export * from './@esmx/router/index.mjs';
export * from './@esmx/class-state/index.mjs';
`;
  try {
    writeFileSync(rootIndexPath, rootContent, 'utf-8');
    console.log(`âœ… ssr-npm-base: Created ${rootIndexPath}`);
  } catch (err) {
    console.error(`âŒ ssr-npm-base: Failed to create root index: ${err.message}`);
    success = false;
  }

  return success;
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸ”§ Post-build: Creating stable index.mjs entry points...\n');
  
  let successCount = 0;
  let failCount = 0;
  
  // Process regular micro-apps
  for (const app of microApps) {
    const entryInfo = findEntryClient(app);
    
    if (entryInfo) {
      const clientSuccess = createIndexMjs(app, entryInfo);
      const rootSuccess = createRootIndexMjs(app, entryInfo);

      const vueSuccess =
        app === 'ssr-npm-vue2' || app === 'ssr-npm-vue3'
          ? createStableVueEntry(app)
          : false;
      
      // Create React provider entries (ESM wrappers using esm.sh)
      const reactSuccess = app === 'ssr-npm-react'
        ? createReactProviderEntries(app)
        : false;
      
      if (clientSuccess || rootSuccess || vueSuccess || reactSuccess) {
        successCount++;
      } else {
        failCount++;
      }
    } else {
      failCount++;
    }
  }
  
  // Process ssr-npm-base shared modules
  const baseSuccess = createSharedModuleIndexes();
  if (baseSuccess) {
    successCount++;
  }
  
  console.log(`\nðŸ“Š Summary: ${successCount} succeeded, ${failCount} failed`);
  
  if (failCount > 0) {
    process.exit(1);
  }
  
  console.log('âœ¨ Post-build complete!');
}

main();
