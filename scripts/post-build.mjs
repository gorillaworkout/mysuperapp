#!/usr/bin/env node
/**
 * Post-build script to create stable index.mjs entry points
 * 
 * Problem: ESMX build generates hashed filenames (entry.client.{hash}.final.mjs)
 * but public/index.html tries to import static paths (/client/src/index.mjs)
 * 
 * Solution: Create index.mjs files that re-export from the hashed entry files
 * so imports remain stable across builds
 */

import { readdirSync, writeFileSync, existsSync, mkdirSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// All micro-apps that need index.mjs entry points
const microApps = [
  'ssr-react',
  'ssr-vue2', 
  'ssr-vue3',
  'ssr-vue3-ecommerce',
  'ssr-vue3-admin',
  'ssr-npm-react',
  'ssr-npm-vue2',
  'ssr-npm-vue3',
  'ssr-react-blog'
];

// Base directory for micro-apps - go up one level from scripts/
const baseDir = join(__dirname, '..', 'my-super-app');

/**
 * Find the entry.client.*.final.mjs file in the client/src directory
 */
function findEntryClient(appDir) {
  const clientSrcDir = join(baseDir, appDir, 'dist', 'client', 'src');
  
  if (!existsSync(clientSrcDir)) {
    console.warn(`âš ï¸  ${appDir}: client/src directory not found at ${clientSrcDir}`);
    return null;
  }

  try {
    const files = readdirSync(clientSrcDir);
    const entryFile = files.find(f => 
      f.startsWith('entry.client.') && f.endsWith('.final.mjs')
    );
    
    if (entryFile) {
      return { dir: clientSrcDir, file: entryFile };
    }
    
    console.warn(`âš ï¸  ${appDir}: entry.client.*.final.mjs not found in ${clientSrcDir}`);
    return null;
  } catch (err) {
    console.error(`âŒ ${appDir}: Error reading directory: ${err.message}`);
    return null;
  }
}

function shouldExportDefault(appDir) {
  // ssr-npm-vue2 uses `export { Vue as default }` â€” see createIndexMjs special case
  if (appDir === 'ssr-npm-vue2') return true;
  return !appDir.startsWith('ssr-npm-');
}

function isReactProvider(appDir) {
  return appDir === 'ssr-npm-react';
}

/**
 * Create stable React entry files with proper ESM exports
 * 
 * The bundled React from ESMX/Rspack is a CommonJS IIFE that doesn't have proper ESM exports.
 * We solve this by creating ESM wrappers that:
 * 1. Execute the bundled IIFE to get the React object
 * 2. Re-export all React APIs as named ESM exports
 * 
 * This approach works entirely offline - no CDN required!
 */
function createReactProviderEntries(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client');
  if (!existsSync(clientDir)) return false;

  // Find the bundled React files
  let reactBundleFile = null;
  let reactDomBundleFile = null;
  
  try {
    const files = readdirSync(clientDir);
    reactBundleFile = files.find(f => f.startsWith('react.') && f.endsWith('.final.mjs') && !f.includes('react-dom'));
    reactDomBundleFile = files.find(f => f.startsWith('react-dom.') && f.endsWith('.final.mjs'));
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to read client dir: ${err.message}`);
    return false;
  }

  if (!reactBundleFile || !reactDomBundleFile) {
    console.error(`âŒ ${appDir}: Could not find React bundle files`);
    return false;
  }

  // Read the bundled React file
  const bundlePath = join(clientDir, reactBundleFile);
  let bundleContent;
  try {
    bundleContent = readFileSync(bundlePath, 'utf-8');
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to read React bundle: ${err.message}`);
    return false;
  }
  
  // The bundle structure is:
  // var e={...},t={};!function r(n){...}(155);
  // The IIFE returns the exports but doesn't assign to anything
  // We need to modify it to return the result
  
  // Transform the bundle: change "!function" to "return function" so we can capture the result
  // Also need to handle the case where it might start with "var e=..."
  let modifiedBundle = bundleContent;
  
  // The bundle ends with: }(155); or similar
  // We need to wrap it so the IIFE result is returned
  // Strategy: wrap entire bundle and return the result of the IIFE
  
  // Find and modify the IIFE invocation pattern
  // Pattern: !function r(n){...}(155);
  // Change to: (function r(n){...})(155)
  // Then we can capture the return value
  
  // Actually, looking at the bundle structure more carefully:
  // The IIFE is structured to populate t[155].exports
  // But we need to capture that value
  
  // Simpler approach: append code to return the exports
  // After the IIFE runs, t[155].exports contains React
  // We can access it by modifying the structure
  
  // Transform: wrap in a function that captures the webpack runtime result
  const transformedReact = `// Auto-generated by post-build script
// ESM wrapper for React 18.3.1 - NO CDN REQUIRED
// Generated at: ${new Date().toISOString()}

// Execute bundled React and capture exports
// The bundle uses webpack-style runtime: e=modules, t=cache
// After execution, the result is in the module cache
const React = (function() {
  // The bundled code structure:
  // var e={...modules...},t={};!function r(n){...runtime...}(155);
  // We modify it to return the result
  
  var __result;
  
  // Execute bundle with modified IIFE to capture result
  ${bundleContent.replace(
    /!\s*function\s+(\w+)\s*\((\w+)\)\s*\{/,
    '__result = (function $1($2) {'
  ).replace(
    /\}\s*\(\s*(\d+)\s*\)\s*;?\s*$/,
    '})($1);'
  )}
  
  return __result;
})();

// Named exports
export const Children = React.Children;
export const Component = React.Component;
export const Fragment = React.Fragment;
export const Profiler = React.Profiler;
export const PureComponent = React.PureComponent;
export const StrictMode = React.StrictMode;
export const Suspense = React.Suspense;
export const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
export const act = React.act;
export const cloneElement = React.cloneElement;
export const createContext = React.createContext;
export const createElement = React.createElement;
export const createFactory = React.createFactory;
export const createRef = React.createRef;
export const forwardRef = React.forwardRef;
export const isValidElement = React.isValidElement;
export const lazy = React.lazy;
export const memo = React.memo;
export const startTransition = React.startTransition;
export const unstable_act = React.unstable_act;
export const useCallback = React.useCallback;
export const useContext = React.useContext;
export const useDebugValue = React.useDebugValue;
export const useDeferredValue = React.useDeferredValue;
export const useEffect = React.useEffect;
export const useId = React.useId;
export const useImperativeHandle = React.useImperativeHandle;
export const useInsertionEffect = React.useInsertionEffect;
export const useLayoutEffect = React.useLayoutEffect;
export const useMemo = React.useMemo;
export const useReducer = React.useReducer;
export const useRef = React.useRef;
export const useState = React.useState;
export const useSyncExternalStore = React.useSyncExternalStore;
export const useTransition = React.useTransition;
export const version = React.version;

export default React;
`;

  // ReactDOM bundle structure:
  // import*as e from"react";var n={...},t={};!function e(r){...}(316);
  // 
  // This is a HYBRID format:
  // - Starts with ESM import for React
  // - Uses webpack-style CommonJS runtime internally
  // - IIFE at the end returns exports but discards them
  //
  // Solution: Capture the IIFE result and re-export properly
  const reactDomBundlePath = join(clientDir, reactDomBundleFile);
  const reactDomBundleContent = readFileSync(reactDomBundlePath, 'utf-8');
  
  // Transform the bundle:
  // 1. Fix React import path: "react" -> "./react.mjs"
  // 2. Capture IIFE result at END of file: },t={};!function e(r){...}(316);
  //    -> },t={};var __ReactDOMExports = (function e(r){...})(316);
  // 3. Export the captured result
  
  let fixedContent = reactDomBundleContent
    // Fix React import path
    .replace(
      /import\s*\*\s*as\s+(\w+)\s+from\s*["']react["']/g,
      'import * as $1 from "./react.mjs"'
    );
  
  // Find the webpack runtime IIFE at the end of the file
  // Pattern: },t={};!function e(r){...}(316);
  // This is the LAST !function in the file, so we need to match it specifically
  // The pattern is: }(number) at the very end, preceded by the IIFE
  const iifeMatch = fixedContent.match(/},\s*(\w+)\s*=\s*\{\s*\}\s*;\s*!\s*function\s+(\w+)\s*\((\w+)\)\s*\{(.+)\}\s*\(\s*(\d+)\s*\)\s*;?\s*$/s);
  
  if (iifeMatch) {
    // iifeMatch[1] = cache var name (t)
    // iifeMatch[2] = function name (e)  
    // iifeMatch[3] = param name (r)
    // iifeMatch[4] = function body
    // iifeMatch[5] = entry point number (316)
    const cacheVar = iifeMatch[1];
    const funcName = iifeMatch[2];
    const paramName = iifeMatch[3];
    const funcBody = iifeMatch[4];
    const entryPoint = iifeMatch[5];
    
    // Replace the IIFE with a variable assignment
    fixedContent = fixedContent.replace(
      /},\s*(\w+)\s*=\s*\{\s*\}\s*;\s*!\s*function\s+(\w+)\s*\((\w+)\)\s*\{(.+)\}\s*\(\s*(\d+)\s*\)\s*;?\s*$/s,
      `},${cacheVar}={};var __ReactDOMExports = (function ${funcName}(${paramName}) {${funcBody}})(${entryPoint});`
    );
  } else {
    console.warn('âš ï¸ ReactDOM: Could not find webpack runtime IIFE pattern');
  }
  
  const transformedReactDom = `// Auto-generated by post-build script
// ESM wrapper for ReactDOM 18.3.1 - NO CDN REQUIRED
// Generated at: ${new Date().toISOString()}

${fixedContent}

// Export ReactDOM APIs from captured webpack exports
export const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = __ReactDOMExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
export const createPortal = __ReactDOMExports.createPortal;
export const flushSync = __ReactDOMExports.flushSync;
export const hydrate = __ReactDOMExports.hydrate;
export const render = __ReactDOMExports.render;
export const unmountComponentAtNode = __ReactDOMExports.unmountComponentAtNode;
export const unstable_batchedUpdates = __ReactDOMExports.unstable_batchedUpdates;
export const version = __ReactDOMExports.version;
export const findDOMNode = __ReactDOMExports.findDOMNode;
export const createRoot = __ReactDOMExports.createRoot;
export const hydrateRoot = __ReactDOMExports.hydrateRoot;

// Default export for compatibility
const ReactDOM = {
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  createPortal,
  flushSync,
  hydrate,
  render,
  unmountComponentAtNode,
  unstable_batchedUpdates,
  version,
  findDOMNode,
  createRoot,
  hydrateRoot,
};
export default ReactDOM;
`;

  // ReactDOM/client for React 18 APIs
  const transformedReactDomClient = `// Auto-generated by post-build script
// ESM wrapper for ReactDOM/client 18.3.1 - NO CDN REQUIRED
// Generated at: ${new Date().toISOString()}

import ReactDOM from '../react-dom.mjs';

// React 18 client APIs
export const createRoot = ReactDOM.createRoot;
export const hydrateRoot = ReactDOM.hydrateRoot;
`;

  const reactMjsPath = join(clientDir, 'react.mjs');
  
  try {
    writeFileSync(reactMjsPath, transformedReact, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactMjsPath} (ESM wrapper - NO CDN)`);
    
    const reactDomMjsPath = join(clientDir, 'react-dom.mjs');
    writeFileSync(reactDomMjsPath, transformedReactDom, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactDomMjsPath} (ESM wrapper - NO CDN)`);
    
    // Create react-dom subdirectory if needed
    const reactDomClientDir = join(clientDir, 'react-dom');
    if (!existsSync(reactDomClientDir)) {
      mkdirSync(reactDomClientDir, { recursive: true });
    }
    const reactDomClientPath = join(reactDomClientDir, 'client.mjs');
    writeFileSync(reactDomClientPath, transformedReactDomClient, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactDomClientPath} (ESM wrapper - NO CDN)`);
    
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create React wrappers: ${err.message}`);
    return false;
  }
}

/**
 * Create index.mjs that re-exports from the hashed entry file
 */
function createIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { dir, file } = entryInfo;
  const indexPath = join(dir, 'index.mjs');
  const exportDefault = shouldExportDefault(appDir);

  // Create re-export content
  // We use export * to re-export all named exports
  // and export { default } for the default export
  // Special case: ssr-npm-vue2 bundle exports Vue as named, but consumers do `import Vue from 'ssr-npm-vue2'`
  const needsNamedAsDefault = appDir === 'ssr-npm-vue2';
  const defaultExportLine = needsNamedAsDefault
    ? `export { Vue as default } from './${file}';`
    : exportDefault
      ? `export { default } from './${file}';`
      : '';

  // ssr-npm-vue2/vue3 source code has `export * from 'vue'` but Rspack's CJS-ESM boundary
  // loses the dynamic re-exports. We add explicit `export * from` the Vue bundle.
  let vueReExportLine = '';
  if (appDir === 'ssr-npm-vue3') {
    vueReExportLine = "export * from '../vue.mjs';";
  } else if (appDir === 'ssr-npm-vue2') {
    vueReExportLine = "export * from '../vue.mjs';";
  }

  const content = `// Auto-generated by post-build script
// This file provides a stable entry point that re-exports from the hashed build output
// Generated at: ${new Date().toISOString()}

export * from './${file}';
${vueReExportLine}
${defaultExportLine}
`;

  try {
    writeFileSync(indexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${indexPath} â†’ ./${file}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Also create root index.mjs if the app has one in dist/
 */
function createRootIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { file } = entryInfo;
  const distDir = join(baseDir, appDir, 'dist');
  const rootIndexPath = join(distDir, 'index.mjs');
  const exportDefault = shouldExportDefault(appDir);
  
  // Only create if dist/index.mjs exists or we want to overwrite it
  // The import path is relative from dist/ to dist/client/src/{file}
  const needsNamedAsDefault = appDir === 'ssr-npm-vue2';
  const defaultExportLine = needsNamedAsDefault
    ? `export { Vue as default } from './client/src/${file}';`
    : exportDefault
      ? `export { default } from './client/src/${file}';`
      : '';

  const content = `// Auto-generated by post-build script
// Root entry point that re-exports from client build
// Generated at: ${new Date().toISOString()}

export * from './client/src/${file}';
${defaultExportLine}
`;

  try {
    writeFileSync(rootIndexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${rootIndexPath}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create root index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create stable vue.mjs entry for ssr-npm-vue2/ssr-npm-vue3
 * Vue2 needs a default export (Vue constructor). Vue3 does not have default export.
 */
function createStableVueEntry(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client');
  if (!existsSync(clientDir)) return false;

  try {
    const files = readdirSync(clientDir);
    const vueFile = files.find(f => f.startsWith('vue.') && f.endsWith('.final.mjs'));
    if (!vueFile) return false;

    const vueStablePath = join(clientDir, 'vue.mjs');
    const content = `// Auto-generated by post-build script
// Stable Vue bundle entry for ${appDir}
// Generated at: ${new Date().toISOString()}

export * from './${vueFile}';
${appDir === 'ssr-npm-vue2' ? `export { default } from './${vueFile}';` : ''}
`;
    writeFileSync(vueStablePath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${vueStablePath} â†’ ./${vueFile}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create vue.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create shared module index files for ssr-npm-base
 * This creates stable entry points for @esmx/router, @esmx/class-state, etc.
 */
function createSharedModuleIndexes() {
  const baseDir = join(__dirname, '..', 'my-super-app', 'ssr-npm-base');
  const clientDir = join(baseDir, 'dist', 'client');
  
  if (!existsSync(clientDir)) {
    console.warn('âš ï¸  ssr-npm-base: client directory not found');
    return false;
  }

  const esmxDir = join(clientDir, '@esmx');
  if (!existsSync(esmxDir)) {
    console.warn('âš ï¸  ssr-npm-base: @esmx directory not found');
    return false;
  }

  const sharedModules = [
    { name: 'router', prefix: 'router.' },
    { name: 'class-state', prefix: 'class-state.' }
  ];
  let success = true;

  try {
    const files = readdirSync(esmxDir);
    
    for (const mod of sharedModules) {
      const moduleFile = files.find(f => f.startsWith(mod.prefix) && f.endsWith('.final.mjs'));
      
      if (moduleFile) {
        const moduleDir = join(esmxDir, mod.name);
        
        if (!existsSync(moduleDir)) {
          mkdirSync(moduleDir, { recursive: true });
        }
        
        const indexPath = join(moduleDir, 'index.mjs');
        const content = `// Auto-generated by post-build script
// Stable entry for @esmx/${mod.name}
// Generated at: ${new Date().toISOString()}

export * from '../${moduleFile}';
`;
        writeFileSync(indexPath, content, 'utf-8');
        console.log(`âœ… ssr-npm-base: Created ${indexPath} â†’ ../${moduleFile}`);
      }
    }
  } catch (err) {
    console.error(`âŒ ssr-npm-base: Failed to create shared module indexes: ${err.message}`);
    success = false;
  }

  // Create root client index.mjs that re-exports all shared modules

  const rootIndexPath = join(clientDir, 'index.mjs');
  const rootContent = `// Auto-generated by post-build script
// Root shared modules entry
// Generated at: ${new Date().toISOString()}

export * from './@esmx/router/index.mjs';
export * from './@esmx/class-state/index.mjs';
`;
  try {
    writeFileSync(rootIndexPath, rootContent, 'utf-8');
    console.log(`âœ… ssr-npm-base: Created ${rootIndexPath}`);
  } catch (err) {
    console.error(`âŒ ssr-npm-base: Failed to create root index: ${err.message}`);
    success = false;
  }

  return success;
}

/**
 * Create stable entry points for @esmx/router-react and @esmx/router-vue
 * These are bundled as separate chunks by esmx build and need stable paths
 * so the importmap can reference them without hashed filenames.
 */
function createRouterPackageWrappers() {
  const packages = [
    { provider: 'ssr-npm-react', scope: '@esmx', prefix: 'router-react.' },
    { provider: 'ssr-npm-vue2', scope: '@esmx', prefix: 'router-vue.' },
    { provider: 'ssr-npm-vue3', scope: '@esmx', prefix: 'router-vue.' }
  ];

  let success = true;

  for (const pkg of packages) {
    const esmxDir = join(baseDir, pkg.provider, 'dist', 'client', pkg.scope);

    if (!existsSync(esmxDir)) {
      continue;
    }

    try {
      const files = readdirSync(esmxDir);
      const bundleFile = files.find(f => f.startsWith(pkg.prefix) && f.endsWith('.final.mjs'));

      if (!bundleFile) {
        continue;
      }

      const stableName = pkg.prefix.slice(0, -1) + '.mjs';
      const stablePath = join(esmxDir, stableName);
      const content = `export * from './${bundleFile}';\n`;
      writeFileSync(stablePath, content, 'utf-8');
      console.log(`âœ… ${pkg.provider}: Created ${stablePath} â†’ ./${bundleFile}`);
    } catch (err) {
      console.error(`âŒ ${pkg.provider}: Failed to create router wrapper: ${err.message}`);
      success = false;
    }
  }

  return success;
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸ”§ Post-build: Creating stable index.mjs entry points...\n');
  
  let successCount = 0;
  let failCount = 0;
  
  // Process regular micro-apps
  for (const app of microApps) {
    const entryInfo = findEntryClient(app);
    
    if (entryInfo) {
      const clientSuccess = createIndexMjs(app, entryInfo);
      const rootSuccess = createRootIndexMjs(app, entryInfo);

      const vueSuccess =
        app === 'ssr-npm-vue2' || app === 'ssr-npm-vue3'
          ? createStableVueEntry(app)
          : false;
      
      // Create React provider entries (local ESM wrappers, no CDN)
      const reactSuccess = app === 'ssr-npm-react'
        ? createReactProviderEntries(app)
        : false;
      
      if (clientSuccess || rootSuccess || vueSuccess || reactSuccess) {
        successCount++;
      } else {
        failCount++;
      }
    } else {
      failCount++;
    }
  }
  
  // Process ssr-npm-base shared modules
  const baseSuccess = createSharedModuleIndexes();
  if (baseSuccess) {
    successCount++;
  }

  // Create stable wrappers for @esmx/router-react and @esmx/router-vue
  const routerSuccess = createRouterPackageWrappers();
  if (routerSuccess) {
    successCount++;
  }
  
  console.log(`\nðŸ“Š Summary: ${successCount} succeeded, ${failCount} failed`);
  
  if (failCount > 0) {
    process.exit(1);
  }
  
  console.log('âœ¨ Post-build complete!');
}

main();
