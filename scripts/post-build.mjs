#!/usr/bin/env node
/**
 * Post-build script to create stable index.mjs entry points
 * 
 * Problem: ESMX build generates hashed filenames (entry.client.{hash}.final.mjs)
 * but public/index.html tries to import static paths (/client/src/index.mjs)
 * 
 * Solution: Create index.mjs files that re-export from the hashed entry files
 * so imports remain stable across builds
 */

import { readdirSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// All micro-apps that need index.mjs entry points
const microApps = [
  'ssr-react',
  'ssr-vue2', 
  'ssr-vue3',
  'ssr-vue3-ecommerce',
  'ssr-vue3-admin',
  'ssr-npm-react',
  'ssr-npm-vue2',
  'ssr-npm-vue3'
];

// Base directory for micro-apps - go up one level from scripts/
const baseDir = join(__dirname, '..', 'my-super-app');

/**
 * Find the entry.client.*.final.mjs file in the client/src directory
 */
function findEntryClient(appDir) {
  const clientSrcDir = join(baseDir, appDir, 'dist', 'client', 'src');
  
  if (!existsSync(clientSrcDir)) {
    console.warn(`âš ï¸  ${appDir}: client/src directory not found at ${clientSrcDir}`);
    return null;
  }

  try {
    const files = readdirSync(clientSrcDir);
    const entryFile = files.find(f => 
      f.startsWith('entry.client.') && f.endsWith('.final.mjs')
    );
    
    if (entryFile) {
      return { dir: clientSrcDir, file: entryFile };
    }
    
    console.warn(`âš ï¸  ${appDir}: entry.client.*.final.mjs not found in ${clientSrcDir}`);
    return null;
  } catch (err) {
    console.error(`âŒ ${appDir}: Error reading directory: ${err.message}`);
    return null;
  }
}

function shouldExportDefault(appDir) {
  return !appDir.startsWith('ssr-npm-');
}

function isVueProvider(appDir) {
  return appDir === 'ssr-npm-vue2' || appDir === 'ssr-npm-vue3';
}

function isReactProvider(appDir) {
  return appDir === 'ssr-npm-react';
}

/**
 * Create stable React entry files with proper ESM exports
 * The bundled React from ESMX is CommonJS-wrapped and doesn't export properly
 * We create wrapper files that use dynamic import and expose React's API
 * 
 * NOTE: Since the bundled React doesn't export properly, we use esm.sh as fallback
 * This is the only practical solution without modifying the bundler itself
 */
function createReactProviderEntries(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client');
  if (!existsSync(clientDir)) return false;

  // Find the bundled React files
  let reactBundleFile = null;
  let reactDomBundleFile = null;
  
  try {
    const files = readdirSync(clientDir);
    reactBundleFile = files.find(f => f.startsWith('react.') && f.endsWith('.final.mjs') && !f.includes('react-dom'));
    reactDomBundleFile = files.find(f => f.startsWith('react-dom.') && f.endsWith('.final.mjs'));
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to read client dir: ${err.message}`);
    return false;
  }

  // Create react.mjs - ESM wrapper using esm.sh (the bundled file doesn't work)
  // The bundled React is CommonJS-wrapped IIFE without proper ESM exports
  const reactMjsPath = join(clientDir, 'react.mjs');
  const reactContent = `// Auto-generated by post-build script
// ESM wrapper for React - uses esm.sh because bundled React is CommonJS
// Generated at: ${new Date().toISOString()}

// Note: The bundled react.*.final.mjs is a CommonJS IIFE without ESM exports
// Using esm.sh as the only practical way to get proper ESM React
export * from 'https://esm.sh/react@18.3.1';
export { default } from 'https://esm.sh/react@18.3.1';
`;

  // Create react-dom.mjs
  const reactDomMjsPath = join(clientDir, 'react-dom.mjs');
  const reactDomContent = `// Auto-generated by post-build script
// ESM wrapper for ReactDOM - uses esm.sh because bundled ReactDOM is CommonJS
// Generated at: ${new Date().toISOString()}

export * from 'https://esm.sh/react-dom@18.3.1?deps=react@18.3.1';
export { default } from 'https://esm.sh/react-dom@18.3.1?deps=react@18.3.1';
`;

  // Create react-dom/client.mjs for React 18 APIs
  const reactDomClientDir = join(clientDir, 'react-dom');
  const reactDomClientPath = join(reactDomClientDir, 'client.mjs');
  const reactDomClientContent = `// Auto-generated by post-build script
// ESM wrapper for ReactDOM/client (React 18 APIs)
// Generated at: ${new Date().toISOString()}

export * from 'https://esm.sh/react-dom@18.3.1/client?deps=react@18.3.1';
`;

  try {
    writeFileSync(reactMjsPath, reactContent, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactMjsPath} (ESM wrapper for React)`);
    
    writeFileSync(reactDomMjsPath, reactDomContent, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactDomMjsPath} (ESM wrapper for ReactDOM)`);
    
    // Create react-dom subdirectory if needed
    if (!existsSync(reactDomClientDir)) {
      mkdirSync(reactDomClientDir, { recursive: true });
    }
    writeFileSync(reactDomClientPath, reactDomClientContent, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${reactDomClientPath} (ESM wrapper for ReactDOM/client)`);
    
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create React wrappers: ${err.message}`);
    return false;
  }
}

function createVueProviderIndex(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client', 'src');
  if (!existsSync(clientDir)) return false;

  const isVue2 = appDir === 'ssr-npm-vue2';
  const indexPath = join(clientDir, 'index.mjs');

  const content = `// Auto-generated by post-build script
// Stable provider entry for ${appDir}
// Generated at: ${new Date().toISOString()}

${isVue2 ? "import Vue from 'vue';" : "import { computed, inject, shallowRef, h } from 'vue';"}
import { Router } from '@esmx/router';

${isVue2 ? `const RouterVuePlugin = {
  install(vueInstance, options) {
    const router =
      (options && options.router) ||
      (typeof Router.getInstance === 'function' ? Router.getInstance() : null);
    if (!router) {
      console.warn('[esmx-router-vue2] Router instance not provided.');
      return;
    }
    this.router = router;

    // Support sharedRouter for cross-app navigation
    const sharedRouter = options && options.sharedRouter;
    if (sharedRouter) {
      vueInstance.prototype.$sharedRouter = sharedRouter;
    }

    vueInstance.prototype.$router = router;

    vueInstance.mixin({
      beforeCreate() {
        if (this.$options.router) {
          this._routerRoot = this;
          this._router = router;

          try {
            this._route = router.route;
          } catch (e) {}

          const unsubscribe = router.afterEach((route) => {
            this._route = route;
            this.$forceUpdate();
          });

          this.$once('hook:destroyed', unsubscribe);
        } else {
          this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
        }
      },
      destroyed() {
        if (this._routerRoot === this) {
          this._routerRoot = null;
        }
      }
    });

    Object.defineProperty(vueInstance.prototype, '$route', {
      get() { return this._routerRoot._route || {}; }
    });

    vueInstance.component('router-link', {
      props: {
        to: { type: [String, Object], required: true },
        replace: { type: Boolean, default: false },
        activeClass: { type: String, default: 'active' },
        tag: { type: String, default: 'a' }
      },
      render(h) {
        const path = typeof this.to === 'string' ? this.to : this.to.path;
        const isActive = this.$router && path === window.location.pathname;

        const classes = [];
        if (this.$vnode.data && this.$vnode.data.staticClass) {
          classes.push(this.$vnode.data.staticClass);
        }
        if (isActive && this.activeClass) {
          classes.push(this.activeClass);
        }

        // Use sharedRouter for cross-app navigation if available, fallback to localRouter
        const router = this.$sharedRouter || this.$router;

        const data = {
          class: classes,
          on: {
            click: (e) => {
              e.preventDefault();
              router.push(path, this.replace);
            }
          },
          attrs: { href: path }
        };

        return h(this.tag, data, this.$slots.default);
      }
    });

    vueInstance.component('router-view', {
      data() {
        return {
          currentRoute: router.route
        };
      },
      created() {
        // Subscribe to route changes and update local state
        this._unsubscribe = router.afterEach((route) => {
          this.currentRoute = route;
        });
      },
      beforeDestroy() {
        if (this._unsubscribe) {
          this._unsubscribe();
        }
      },
      render(h) {
        const route = this.currentRoute || this.$route;
        const matched = route && route.matched;
        const component = matched && matched.length > 0
          ? matched[matched.length - 1].component
          : null;

        if (!component) return null;
        return h(component);
      }
    });
  }
};

function install(vueInstance, options) {
  vueInstance.use(RouterVuePlugin, options);
}

function RouterView(VueCtor) {
  const router = Router.getInstance && Router.getInstance();
  return VueCtor.component('router-view', {
    data() {
      return {
        currentRoute: router ? router.route : null
      };
    },
    created() {
      if (router) {
        this._unsubscribe = router.afterEach((route) => {
          this.currentRoute = route;
        });
      }
    },
    beforeDestroy() {
      if (this._unsubscribe) {
        this._unsubscribe();
      }
    },
    render(h) {
      const route = this.currentRoute || this.$route;
      const matched = route && route.matched;
      const component = matched && matched.length > 0
        ? matched[matched.length - 1].component
        : null;
      if (!component) return null;
      return h(component);
    }
  });
}

function RouterLink(VueCtor) {
  return VueCtor.component('router-link', {
    props: {
      to: { type: [String, Object], required: true },
      replace: { type: Boolean, default: false },
      activeClass: { type: String, default: 'active' },
      tag: { type: String, default: 'a' }
    },
    render(h) {
      const localRouter = this.$router || (Router.getInstance && Router.getInstance());
      const sharedRouter = this.$sharedRouter || null;
      const path = typeof this.to === 'string' ? this.to : this.to.path;
      const isActive = localRouter && path === window.location.pathname;

      const classes = [];
      if (isActive && this.activeClass) {
        classes.push(this.activeClass);
      }

      const currentPath = window.location.pathname;
      const currentAppPrefix = currentPath.split('/').slice(0, 2).join('/');
      const isCrossAppNavigation = !path.startsWith(currentAppPrefix) || path === '/';

      const data = {
        class: classes,
        on: {
          click: (e) => {
            e.preventDefault();
            if (sharedRouter) {
              if (this.replace) sharedRouter.replace(path);
              else sharedRouter.push(path);
            } else if (isCrossAppNavigation) {
              if (this.replace) window.location.replace(path);
              else window.location.href = path;
            } else if (localRouter) {
              localRouter.push(path, this.replace);
            }
          }
        },
        attrs: { href: path }
      };

      return h(this.tag, data, this.$slots.default);
    }
  });
}
` : `const RouterVuePlugin = {
  install(app, options) {
    const router = options && options.router;
    if (!router) {
      console.warn('RouterVuePlugin installed without router instance.');
      return;
    }

    // Support sharedRouter for cross-app navigation
    const sharedRouter = options && options.sharedRouter;
    if (sharedRouter) {
      app.config.globalProperties.$sharedRouter = sharedRouter;
      app.provide('sharedRouter', sharedRouter);
    }

    app.config.globalProperties.$router = router;
    app.provide('router', router);

    const routeRef = shallowRef(router.route);
    app.provide('route', routeRef);

    const unsubscribe = router.afterEach((to) => {
      routeRef.value = to;
    });

    app.mixin({
      beforeUnmount() {
        if (this.$options.name === 'App' || this === (app._instance && app._instance.proxy)) {
          unsubscribe();
        }
      }
    });

    app.component('router-link', {
      props: {
        to: { type: [String, Object], required: true },
        replace: { type: Boolean, default: false },
        activeClass: { type: String, default: 'active' }
      },
      setup(props, { slots }) {
        const localRouter = inject('router');
        const sharedRouter = inject('sharedRouter', null);
        const routeRef = inject('route');

        const path = computed(() => typeof props.to === 'string' ? props.to : props.to.path);

        const isActive = computed(() => {
          return routeRef.value && routeRef.value.path === path.value;
        });

        const classes = computed(() => {
          const result = [];
          if (isActive.value && props.activeClass) result.push(props.activeClass);
          return result;
        });

        const handleClick = (e) => {
          e.preventDefault();
          const currentPath = routeRef.value?.path || '';
          const currentAppPrefix = currentPath.split('/').slice(0, 2).join('/');
          const isCrossAppNavigation = !path.value.startsWith(currentAppPrefix) || path.value === '/';
          
          if (sharedRouter) {
            if (props.replace) sharedRouter.replace(path.value);
            else sharedRouter.push(path.value);
          } else if (isCrossAppNavigation) {
            if (props.replace) window.location.replace(path.value);
            else window.location.href = path.value;
          } else {
            if (props.replace) localRouter.replace(path.value);
            else localRouter.push(path.value);
          }
        };

        return () => h('a', {
          href: path.value,
          class: classes.value,
          onClick: handleClick
        }, slots.default ? slots.default() : []);
      }
    });

    app.component('router-view', {
      setup() {
        const routeRef = inject('route');
        const Component = computed(() => {
          if (!routeRef || !routeRef.value) return null;
          const matched = routeRef.value.matched;
          return matched && matched.length > 0 ? matched[matched.length - 1].component : null;
        });
        return () => Component.value ? h(Component.value) : null;
      }
    });
  }
};

function install(app, options) {
  app.use(RouterVuePlugin, options);
}

function useRouter() {
  const router = inject('router');
  if (!router) {
    throw new Error('useRouter must be used within RouterProvider (via RouterVuePlugin)');
  }
  return router;
}

function useRoute() {
  const route = inject('route');
  if (!route) {
    throw new Error('useRoute must be used within RouterProvider (via RouterVuePlugin)');
  }
  return route;
}
`}

export { RouterVuePlugin, install };
${isVue2 ? 'export { RouterLink, RouterView };' : 'export { useRouter, useRoute };'}
export * from 'vue';
${isVue2 ? "export { default } from 'vue';" : ''}
export * from '@esmx/router';
`;

  try {
    writeFileSync(indexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${indexPath} (custom provider entry)`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create provider index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create index.mjs that re-exports from the hashed entry file
 */
function createIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { dir, file } = entryInfo;
  const indexPath = join(dir, 'index.mjs');
  const exportDefault = shouldExportDefault(appDir);

  if (isVueProvider(appDir)) {
    return createVueProviderIndex(appDir);
  }
  
  // Create re-export content
  // We use export * to re-export all named exports
  // and export { default } for the default export
  const content = `// Auto-generated by post-build script
// This file provides a stable entry point that re-exports from the hashed build output
// Generated at: ${new Date().toISOString()}

export * from './${file}';
${exportDefault ? `export { default } from './${file}';` : ''}
`;

  try {
    writeFileSync(indexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${indexPath} â†’ ./${file}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Also create root index.mjs if the app has one in dist/
 */
function createRootIndexMjs(appDir, entryInfo) {
  if (!entryInfo) return false;

  const { file } = entryInfo;
  const distDir = join(baseDir, appDir, 'dist');
  const rootIndexPath = join(distDir, 'index.mjs');
  const exportDefault = shouldExportDefault(appDir);
  
  // Only create if dist/index.mjs exists or we want to overwrite it
  // The import path is relative from dist/ to dist/client/src/{file}
  const isProvider = isVueProvider(appDir);
  const clientTarget = isProvider ? 'index.mjs' : file;
  const rootExportDefault =
    isProvider ? appDir === 'ssr-npm-vue2' : exportDefault;

  const content = `// Auto-generated by post-build script
// Root entry point that re-exports from client build
// Generated at: ${new Date().toISOString()}

export * from './client/src/${clientTarget}';
${rootExportDefault ? `export { default } from './client/src/${clientTarget}';` : ''}
`;

  try {
    writeFileSync(rootIndexPath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${rootIndexPath}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create root index.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create stable vue.mjs entry for ssr-npm-vue2/ssr-npm-vue3
 * Vue2 needs a default export (Vue constructor). Vue3 does not have default export.
 */
function createStableVueEntry(appDir) {
  const clientDir = join(baseDir, appDir, 'dist', 'client');
  if (!existsSync(clientDir)) return false;

  try {
    const files = readdirSync(clientDir);
    const vueFile = files.find(f => f.startsWith('vue.') && f.endsWith('.final.mjs'));
    if (!vueFile) return false;

    const vueStablePath = join(clientDir, 'vue.mjs');
    const content = `// Auto-generated by post-build script
// Stable Vue bundle entry for ${appDir}
// Generated at: ${new Date().toISOString()}

export * from './${vueFile}';
${appDir === 'ssr-npm-vue2' ? `export { default } from './${vueFile}';` : ''}
`;
    writeFileSync(vueStablePath, content, 'utf-8');
    console.log(`âœ… ${appDir}: Created ${vueStablePath} â†’ ./${vueFile}`);
    return true;
  } catch (err) {
    console.error(`âŒ ${appDir}: Failed to create vue.mjs: ${err.message}`);
    return false;
  }
}

/**
 * Create shared module index files for ssr-npm-base
 * This creates stable entry points for @esmx/router, @esmx/class-state, etc.
 */
function createSharedModuleIndexes() {
  const baseDir = join(__dirname, '..', 'my-super-app', 'ssr-npm-base');
  const clientDir = join(baseDir, 'dist', 'client');
  
  if (!existsSync(clientDir)) {
    console.warn('âš ï¸  ssr-npm-base: client directory not found');
    return false;
  }

  const esmxDir = join(clientDir, '@esmx');
  if (!existsSync(esmxDir)) {
    console.warn('âš ï¸  ssr-npm-base: @esmx directory not found');
    return false;
  }

  const sharedModules = [
    { name: 'router', prefix: 'router.' },
    { name: 'class-state', prefix: 'class-state.' }
  ];
  let success = true;

  try {
    const files = readdirSync(esmxDir);
    
    for (const mod of sharedModules) {
      const moduleFile = files.find(f => f.startsWith(mod.prefix) && f.endsWith('.final.mjs'));
      
      if (moduleFile) {
        const moduleDir = join(esmxDir, mod.name);
        
        if (!existsSync(moduleDir)) {
          mkdirSync(moduleDir, { recursive: true });
        }
        
        const indexPath = join(moduleDir, 'index.mjs');
        const content = `// Auto-generated by post-build script
// Stable entry for @esmx/${mod.name}
// Generated at: ${new Date().toISOString()}

export * from '../${moduleFile}';
`;
        writeFileSync(indexPath, content, 'utf-8');
        console.log(`âœ… ssr-npm-base: Created ${indexPath} â†’ ../${moduleFile}`);
      }
    }
  } catch (err) {
    console.error(`âŒ ssr-npm-base: Failed to create shared module indexes: ${err.message}`);
    success = false;
  }

  // Create root client index.mjs that re-exports all shared modules

  const rootIndexPath = join(clientDir, 'index.mjs');
  const rootContent = `// Auto-generated by post-build script
// Root shared modules entry
// Generated at: ${new Date().toISOString()}

export * from './@esmx/router/index.mjs';
export * from './@esmx/class-state/index.mjs';
`;
  try {
    writeFileSync(rootIndexPath, rootContent, 'utf-8');
    console.log(`âœ… ssr-npm-base: Created ${rootIndexPath}`);
  } catch (err) {
    console.error(`âŒ ssr-npm-base: Failed to create root index: ${err.message}`);
    success = false;
  }

  return success;
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸ”§ Post-build: Creating stable index.mjs entry points...\n');
  
  let successCount = 0;
  let failCount = 0;
  
  // Process regular micro-apps
  for (const app of microApps) {
    const entryInfo = findEntryClient(app);
    
    if (entryInfo) {
      const clientSuccess = createIndexMjs(app, entryInfo);
      const rootSuccess = createRootIndexMjs(app, entryInfo);

      const vueSuccess =
        app === 'ssr-npm-vue2' || app === 'ssr-npm-vue3'
          ? createStableVueEntry(app)
          : false;
      
      // Create React provider entries (ESM wrappers using esm.sh)
      const reactSuccess = app === 'ssr-npm-react'
        ? createReactProviderEntries(app)
        : false;
      
      if (clientSuccess || rootSuccess || vueSuccess || reactSuccess) {
        successCount++;
      } else {
        failCount++;
      }
    } else {
      failCount++;
    }
  }
  
  // Process ssr-npm-base shared modules
  const baseSuccess = createSharedModuleIndexes();
  if (baseSuccess) {
    successCount++;
  }
  
  console.log(`\nðŸ“Š Summary: ${successCount} succeeded, ${failCount} failed`);
  
  if (failCount > 0) {
    process.exit(1);
  }
  
  console.log('âœ¨ Post-build complete!');
}

main();
